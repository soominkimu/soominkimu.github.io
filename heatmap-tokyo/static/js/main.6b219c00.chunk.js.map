{"version":3,"sources":["CalUtil.js","WeatherUtil.js","App.js","serviceWorker.js","index.js"],"names":["IsLeapYear","y","scaleRange","min","max","w","itemPercent","v","item","Number","toFixed","heatMapColor","p","op","arguments","length","undefined","l","concat","drawLine","ctx","x","x2","y2","beginPath","moveTo","lineTo","stroke","CanvasCompo","props","_this","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","h","updateCanvas","bind","assertThisInitialized","url","callback","fetch","then","response","contentType","headers","get","console","log","includes","json","TypeError","data","catch","error","wData","refs","canvas","getContext","m","yrFr","meta","from","substring","yrTo","to","yrTotal","bLeap","d","grd","createLinearGradient","pct","pct_max","addColorStop","save","shadowColor","shadowOffsetX","shadowOffsetY","shadowBlur","fillStyle","fillRect","restore","forEach","lineWidth","strokeStyle","gw","gh","W","H","xv","yv","drawGrid","strokeRect","n","gridVerticalYear","react_default","a","createElement","ref","width","height","React","Component","App","className","App_CanvasCompo","Boolean","window","location","hostname","match","ReactDOM","render","src_App_0","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.6b219c00.chunk.js","sourcesContent":["// CalUtil\n//\nimport Names from './names.json';\n\n// Check if the given year is a leap year in the Gregorian calendar\nexport const IsLeapYear = (y =>\n  ((y % 4   === 0) &&\n   (y % 100 !== 0)) ||\n   (y % 400 === 0));\n\n// const DaysInMonth = (m, y) => new Date(y, m, 0).getDate();\n// m: 1..12\n// Gregorian Calendar: Sep. 1752 -> 1,2,14,...30 (11 days advanced)\nexport const DaysInMonth = (m, y) => {\n  switch (m) {\n    case 4:\n    case 6:\n    case 9:\n    case 11: return 30;\n    case 2:  return IsLeapYear(y) ? 29 : 28;\n    default: return 31;\n  }\n}\n\n// Count the number of days with the year up to the specified date\n// m starts from 1\nexport const NthDayInYear = (yr, m, d) => {\n/*\n  let mo = 1;\n  let days = 0;\n  while (mo < m) {\n    days += DaysInMonth(mo, yr);  // add up days to the previous month\n    mo++;\n  }\n*/\n  // For the optimized performance, avoid the loop and use the pre-calculated array\n  // accumulated days until the month\n  const accDays = [\n    0,\n    31,\n    31+28,\n    31+28+31,\n    31+28+31+30,\n    31+28+31+30+31,\n    31+28+31+30+31+30,\n    31+28+31+30+31+30+31,\n    31+28+31+30+31+30+31+31,\n    31+28+31+30+31+30+31+31+30,\n    31+28+31+30+31+30+31+31+30+31,\n    31+28+31+30+31+30+31+31+30+31+30\n  // 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11 month\n  ];\n  if (m < 1 || m > 12)\n    return 0;  // valid range check\n  let days = accDays[m-1];\n  if (m > 2 && IsLeapYear(yr))\n    days++;\n  return (days + d);\n}\n\n// 元号 from 西暦\nexport const GengoYear = (yr) => {\n  for (let i = (Names.Gengo.yr.length - 1); i >= 0; i--)\n    if (yr >= Names.Gengo.yr[i])\n      return Names.Gengo.jp[i] + (yr - Names.Gengo.yr[i] + 1);\n  return yr;   // out of range, just return yr\n}\n\nexport const deg2rad = (deg) => deg*Math.PI/180;\n\n// get Julian Day Number\n// Invented in 1583 by Joseph Scaliger\n// The 7980 year cycle (solar, lunar, and a particular Roman tax cycle)\n// Jan.1,4713 B.C. at noon GMT ~ Jan.22,3268 at noon GMT\n// The number of days from Jan. 1, 4713 B.C. at 12:00:00 GMT, until Jan. 1, 1970 at 00:00:00 UTC\n// A day is 86,400 seconds long. UNIX TIM / 86400000 is the number of days since Jan. 1, 1970\n// new Date gives you the number of seconds from epoch until whatever loca ltime your computer has\nexport const getJulianDay = (date) => (date.getTime() / 86400000.0 + 2440587.5);\n\n// SOURCE: https://news.local-group.jp/moonage/moonage.js.txt\nexport const getMoonAge = (date) => {\n  // 新月日計算\n  // 引数  　julian  ユリウス通日\n  // 戻り値  与えられたユリウス通日に対する直前の新月日(ユリウス日)\n  const getNewMoon = (j) => {\n    const n1 = 2451550.09765;\n    const n2 = 29.530589;\n    const n3 = 0.017453292519943;\n    const k  = Math.floor((j - n1) / n2);\n    const t  = k / 1236.85;\n\n    return (\n        n1\n      + n2 * k\n      + 0.0001337 * t * t\n      - 0.40720   * Math.sin((201.5643 + 385.8169 * k) * n3)\n      + 0.17241   * Math.sin((2.5534   +  29.1054 * k) * n3)\n    );\n  }\n  \n  const jd = getJulianDay(date);\n  // console.log('Julian: ', jl);\n  let nm = getNewMoon(jd);\n  // getNewMoonは新月直前の日を与えるとうまく計算できないのでその対処\n  // (一日前の日付で再計算してみる)\n  if (nm > jd) {\n    nm = getNewMoon(jd - 1.0);\n  }\n  // console.log('Moon age:', jd - nm);\n  return (jd - nm);  // moon's age at current time\n}\n\n// 360 degree\nexport const NormalizeDegree = (deg) => {\n  if (deg >= 0 && deg < 360)  // Don't allow 360, it should be rewinded to 0.\n    return deg;\n  let nd = deg % 360;\n  if (nd < 0)\n    nd += 360;\n  return nd;\n}\n\n// Position of the Sun: https://en.wikipedia.org/wiki/Position_of_the_Sun\n// Precision: compared to 国立天文台＞暦計算室＞暦象年表\n// 1.26 ~ 15.41 min (0.0106 degree) for 2019年二十四節気 視黄経 (Tested at Dec.6,2018)\nexport const getPosSun = (date) => {\n  const n = getJulianDay(date) - 2451545.0;\n  // The mean longitude of the Sun, corrected for the aberration of light\n  const L = NormalizeDegree(280.460 + 0.9856474*n);  // in degree\n  // The mean anomaly of the Sun\n  const g = deg2rad(357.528 + 0.9856003*n);  // in radian\n  // The ecliptic longitude of the Sun\n  return {\n    longitude: NormalizeDegree(L + 1.915*Math.sin(g) + 0.020*Math.sin(2*g)),\n    distance: 1.00014 - 0.01671*Math.cos(g) - 0.00014*Math.cos(2*g)\n  };\n}\n\n// Test Modules\n//\nexport const TestCalUtil = () => {\n  console.log(\"***********************\")\n  const date = [\n    new Date(1933,6-1,25,12,0,0),  // GMT+9 -> JST 12:00:00\n    new Date(1967,1-1, 9,12,0,0),\n    new Date(1972,6-1,10,12),\n    new Date(2004,5-1,13,12),\n    new Date()\n  ];\n  date.map(d => console.log(d.toDateString(), Number(getMoonAge(d).toFixed(3))));\n  console.log(NthDayInYear(2018,12,4));\n  console.log(\"getTimezoneOffset:\", date[4].getTimezoneOffset(), \"min\");\n  // http://eco.mtk.nao.ac.jp/cgi-bin/koyomi/cande/phenomena_s.cgi\n  const d24 = [  // 二十四節気\n    new Date(2019, 1-1, 6, 0,39),\n    new Date(2019, 1-1,20,18, 0),\n    new Date(2019, 2-1, 4,12,14),\n    new Date(2019, 2-1,19, 8, 4),\n    new Date(2019, 3-1, 6, 6,10),\n    new Date(2019, 3-1,21, 6,58),\n    new Date(2019, 4-1, 5,10,51),\n    new Date(2019, 4-1,20,17,55),\n    new Date(2019, 5-1, 6, 4, 3),\n    new Date(2019, 5-1,21,16,59),\n    new Date(2019, 6-1, 6, 8, 6),\n    new Date(2019, 6-1,22, 0,54),\n    new Date(2019, 7-1, 7,18,21),\n    new Date(2019, 7-1,23,11,50),\n    new Date(2019, 8-1, 8, 4,13),\n    new Date(2019, 8-1,23,19, 2),\n    new Date(2019, 9-1, 8, 7,17),\n    new Date(2019, 9-1,23,16,50),\n    new Date(2019,10-1, 8,23, 6),\n    new Date(2019,10-1,24, 2,20),\n    new Date(2019,11-1, 8, 2,24),\n    new Date(2019,11-1,22,23,59),\n    new Date(2019,12-1, 7,19,18),\n    new Date(2019,12-1,22,13,19),\n    new Date(2020, 1-1, 6, 6,31),\n    new Date(2020, 1-1,20,23,56),\n  ];\n  let diffMin = 360;\n  let diffMax = 0;\n  const deg2min = (deg) => Number((deg*24*60*365/360).toFixed(2));\n  d24.map((d, i) => {\n    const s = getPosSun(d);\n    const diff = NormalizeDegree(285 + i*15) - ((s.longitude > 350) ? 360 - s.longitude : s.longitude);\n    diffMin = Math.min(diffMin, Math.abs(diff));\n    diffMax = Math.max(diffMax, Math.abs(diff));\n    return console.log(d.toDateString(),\n      \"longitude:\", Number(s.longitude.toFixed(4)),\n      \"AU:\",        Number(s.distance.toFixed(4)),\n      \"error:\",     Number(diff.toFixed(4)), \"|\", deg2min(diff), \"min\"\n    );\n  });\n  console.log(\"Precision(minutes):\", deg2min(diffMin), \"~\", deg2min(diffMax));\n}\n","// WeatherUtil.js\nconst scaleRange = {\n  temp : {\n    min : 0,\n    max : 30,\n    w   : 30-0\n  },\n  humidity : {\n    min : 10,\n    max : 90,\n    w   : 90-10\n  }\n};\n\n// CCS hsl color code from [0,1] val; based on the 5 color heatmap\nconst itemPercent = (v, item) => {\n  //if (v < item.min) return 0;\n  //if (v > item.max) return 1;\n  return Number(((v-item.min)/item.w).toFixed(2));\n}\n\nexport const tempPercent     = (temp) => itemPercent(temp, scaleRange.temp);\nexport const humidityPercent = (hum)  => itemPercent(hum,  scaleRange.humidity);\n\nexport const perc2Temp = (perc) => Number(((scaleRange.temp.w)*perc).toFixed(1));\n\n// 5 color heatmap\n//0    : blue   (hsl(240, 100%, 50%))\n//0.25 : cyan   (hsl(180, 100%, 50%))\n//0.5  : green  (hsl(120, 100%, 50%))\n//0.75 : yellow (hsl( 60, 100%, 50%))\n//1    : red    (hsl(  0, 100%, 50%))\n// https://stackoverflow.com/questions/12875486/what-is-the-algorithm-to-create-colors-for-a-heatmap\n// hue: red primary at 0°, green at 120°, blue at 240°\nexport const heatMapColor = (p, op=.7) => {\n  const lfactor = 200;\n  let l=50;\n  if      (p > 1) l -= (p-1)*lfactor;\n  else if (p < 0) l -= -p*lfactor;\n  //  if      (p < 0) p = 0;\n  // else if (p > 1) p = 1;\n  return `hsla(${Number(((1.0 - p)*240).toFixed(2))},100%,${l}%,${op})`;\n}\n","// weather-view\nimport React from 'react';\nimport './App.css';\nimport {\n  IsLeapYear\n} from './CalUtil';\nimport {\n  tempPercent,\n  //humidityPercent,\n  heatMapColor\n} from './WeatherUtil';\n\n//import weatherData from './dataJSON/M_tokyo-Avg.json';\n\nconst drawLine = (ctx, x, y, x2, y2) => {\n  ctx.beginPath();\n  ctx.moveTo(x, y);\n  ctx.lineTo(x2, y2);\n  ctx.stroke();\n}\n\n// drawing grid with rect():   O(n^2)\n//              with lineTo(): O(2n)\nconst drawGrid = (ctx, x, y, gw, gh, W, H) => {\n  const x2 = x + W;\n  const y2 = y + H;\n  for (let xv=x; xv <= x2; xv += gw) { // vertical lines\n    drawLine(ctx, xv, y, xv, y2);\n  }\n  for (let yv=y; yv <= y2; yv += gh) {  // horizontal lines\n    drawLine(ctx, x, yv, x2, yv);\n  }\n}\n\nconst gridVerticalYear = (ctx, x, y, gh, W) => {\n  const H = gh*366;\n  ctx.beginPath();\n  ctx.strokeRect(x, y, W, H);\n  const x2   = x + W;\n  const days = [31, 29, 31, 30, 31, 30,\n                31, 31, 30, 31, 30, 31];\n  let y2=y;\n  days.forEach(n => {\n    y2 += n*gh;\n    drawLine(ctx, x, y2, x2, y2);\n  });\n}\n\nconst fetchJSON = (url, callback) => {\n  fetch(url)\n    .then(response => {\n       const contentType = response.headers.get(\"content-type\");\n       console.log('contentType:', contentType);\n       if (contentType && contentType.includes(\"application/json\"))\n         return response.json();\n       throw new TypeError(\"Opps, no JSON file!\");\n    })  // parses response to JSON\n    .then(data => callback(data))\n    .catch(error => console.log(error));\n}\n\nclass CanvasCompo extends React.Component {\n  constructor(props) {\n    super(props);\n    this.w = 4;\n    this.h = 2;\n    this.updateCanvas = this.updateCanvas.bind(this);  // callback from fetch\n  }\n\n  componentDidMount() {\n    // ~/D/nodejs/fileserver$ node server.js\n    //fetchJSON('http://localhost:9001/dataJSON/M_tokyo-Avg.json', this.updateCanvas);\n    fetchJSON('https://soominkimu.github.io/data/M_tokyo-Avg.json', this.updateCanvas);\n  }\n\n  componentDidUpdate() {\n    this.updateCanvas();\n  }\n\n  updateCanvas(wData) {\n    const ctx = this.refs.canvas.getContext('2d');\n    const m = {x: 10, y: 30};\n    const w = this.w;\n    const h = this.h;\n    const yrFr = Number(wData.meta.from.substring(0,4));\n    const yrTo = Number(wData.meta.to.substring(0,4));\n    const yrTotal = yrTo - yrFr + 1;\n    console.log(yrFr, yrTo, yrTotal, \"years of data\");\n    let bLeap = IsLeapYear(yrFr);\n    let y=0;  // year count\n    let d=0;  // day (data) count, 0 at the first day of each year\n    let p = {x: m.x, y: m.y};  // to save calculations\n    console.log(yrFr, wData.data.length, 'lines of data');\n\n    const lh = 20;  // legend height\n    let grd = ctx.createLinearGradient(m.x, m.y, w*(yrTotal+1), 0);\n    const pct_max = 1.2;\n    const pct_min = -.2;\n    const pct_w   = pct_max - pct_min;\n    const dpct    = pct_w/30;\n    for (let pct=pct_min; pct <= pct_max; pct += dpct)\n      grd.addColorStop((pct-pct_min)/pct_w, heatMapColor(pct, 1));\n    // ctx.filter = 'blur(4px)';\n    //ctx.filter = 'drop-shadow(4px 4px 2px lightgray)';\n    ctx.save();  // because we are using very expensive process (shadow)\n    ctx.shadowColor = 'LightGray';\n    ctx.shadowOffsetX = 4;\n    ctx.shadowOffsetY = 4;\n    ctx.shadowBlur = 4;\n    ctx.fillStyle = grd;\n    ctx.fillRect(m.x, m.y-lh-6, w*yrTotal, lh);\n    ctx.restore();\n    /*\n    let gd = ctx.createLinearGradient(m.x, m.y, m.x, m.y+h*366);\n    weather.data.forEach(data => {\n      if (data !== null) {\n        gd.addColorStop(d/366, heatMapColor(tempPercent(data), 1));  // hsla\n      }\n      if (d >= 365) {\n        ctx.fillStyle = gd;\n        ctx.fillRect(p.x, m.y, w, h*366);\n        y++;\n        p.x += w;\n        bLeap = IsLeapYear(yrFr + y);\n        d = 0;\n        p.y = m.y;  // carriage return\n        gd = ctx.createLinearGradient(m.x, m.y, m.x, m.y+h*366);\n      } else {\n        d++;\n        p.y += h;\n        if (!bLeap && (d === (31+28))) {\n          ctx.fillStyle = \"Gray\";      // Delete this line to fill with the same color as Feb.28's data\n          ctx.fillRect(p.x, p.y, w, h);\n          d++;  // skip to make up 1 day of Feb.29 for the non-leap year\n          p.y += h;\n        }\n      }\n    }\n    ctx.fillStyle = gd;\n    ctx.fillRect(p.x, m.y, w, h*366);\n    */\n    wData.data.forEach(data => {\n      if (data !== null) {\n        ctx.fillStyle = heatMapColor(tempPercent(data), 1);  // hsla\n        ctx.fillRect(p.x, p.y, w, h);\n      }\n      if (d >= 365) {\n        y++;\n        p.x += w;\n        bLeap = IsLeapYear(yrFr + y);\n        d = 0;\n        p.y = m.y;  // carriage return\n      } else {\n        d++;\n        p.y += h;\n        if (!bLeap && (d === (31+28))) {\n          ctx.fillStyle = \"Gray\";      // Delete this line to fill with the same color as Feb.28's data\n          ctx.fillRect(p.x, p.y, w, h);\n          d++;  // skip to make up 1 day of Feb.29 for the non-leap year\n          p.y += h;\n        }\n      }\n    });\n    ctx.lineWidth = .5;\n    ctx.strokeStyle = \"rgba(0,0,0, .5)\";\n    drawGrid(ctx, m.x, m.y, w, h, w*(y+1), h*366);\n    ctx.lineWidth = 1;\n    ctx.strokeStyle = \"rgba(0,0,0, 1)\";\n    gridVerticalYear(ctx, m.x, m.y, h, w*(y+1));\n  }\n\n  render() {\n    return (\n      <canvas ref=\"canvas\" width={40+this.w*144} height={40+this.h*366*3} />\n    );\n  }\n}\n\nclass App extends React.Component {\n\n  render() {\n    return (\n      <div className=\"App\">\n        <CanvasCompo />\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}